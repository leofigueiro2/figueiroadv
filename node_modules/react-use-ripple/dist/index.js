var react = require('react');

var ANIMATION_LENGTH = 700;
var RIPPLE_SIZE = 100;
var RIPPLE_COLOR = 'rgba(0, 0, 0, 0.3)';

if (typeof document !== 'undefined') {
  var _document$querySelect;

  var style = document.createElement('style');
  var keyframes = "\n    @keyframes use-ripple-animation {\n      from {\n        opacity: 1;\n        transform: scale(0);\n      }\n      to {\n        opacity: 0;\n        transform: scale(10);\n      }\n    }\n    ";
  style.innerHTML = keyframes;
  (_document$querySelect = document.querySelector('head')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.appendChild(style);
}

var defaultEvent = {
  clientX: 0,
  clientY: 0,
  target: null
};

var createRipple = function createRipple(element, options) {
  return function (e) {
    var isExcluded = ((options === null || options === void 0 ? void 0 : options.excludedRefs) || []).some(function (ref) {
      var _ref$current;

      return !!ref.current && ref.current.contains(e === null || e === void 0 ? void 0 : e.target) || ((_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.isSameNode(e === null || e === void 0 ? void 0 : e.target));
    });

    if (isExcluded) {
      return;
    }

    var clientX = (e === null || e === void 0 ? void 0 : e.clientX) || defaultEvent.clientX;
    var clientY = (e === null || e === void 0 ? void 0 : e.clientY) || defaultEvent.clientY;

    var _element$getBoundingC = element.getBoundingClientRect(),
        height = _element$getBoundingC.height,
        width = _element$getBoundingC.width,
        top = _element$getBoundingC.top,
        left = _element$getBoundingC.left;

    var x = clientX - left;
    var y = clientY - top;
    var rippleSize = Math.min(height, width, (options === null || options === void 0 ? void 0 : options.rippleSize) || RIPPLE_SIZE);
    var positionTop = clientX ? y - rippleSize / 2 : rippleSize / 2 - height / 2;
    var positionLeft = clientY ? x - rippleSize / 2 : width / 2 - rippleSize / 2;
    var span = document.createElement('span');
    span.style.cssText = "\n    top: " + positionTop + "px;\n    left: " + positionLeft + "px;\n    position: absolute;\n    border-radius: 50%;\n    background-color: " + ((options === null || options === void 0 ? void 0 : options.rippleColor) || RIPPLE_COLOR) + ";\n    pointer-events: none;\n    width: " + rippleSize + "px;\n    height: " + rippleSize + "px;\n    animation: use-ripple-animation " + ((options === null || options === void 0 ? void 0 : options.animationLength) || ANIMATION_LENGTH) + "ms ease-in;\n  ";
    element.appendChild(span);
    span.addEventListener('animationend', function () {
      element.removeChild(span);
    });
  };
};

var useRipple = function useRipple(ref, options) {
  react.useEffect(function () {
    if ((options === null || options === void 0 ? void 0 : options.disabled) || !(ref === null || ref === void 0 ? void 0 : ref.current)) {
      return;
    }

    var element = ref.current;
    var elementPosition = getComputedStyle(element).getPropertyValue('position');
    element.style.position = elementPosition === 'static' || !elementPosition ? 'relative' : elementPosition;
    element.style.overflow = 'hidden';
    var ripple = createRipple(element, options);

    var keyboardRipple = function keyboardRipple(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        ripple();
      }
    };

    element.addEventListener('mousedown', ripple);
    element.addEventListener('keydown', keyboardRipple);
    return function () {
      element.removeEventListener('mousedown', ripple);
      element.removeEventListener('keydown', keyboardRipple);
    };
  });
};

exports.useRipple = useRipple;
//# sourceMappingURL=index.js.map
